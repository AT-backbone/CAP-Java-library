/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package cap.java.library;

import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Arrays;

/*
 *  Copyright (c) 2016  Niklas Spanring   <n.spanring@backbone.co.at>
 *  Copyright (c) 2016  Guido Schratzer   <guido.schratzer@backbone.co.at>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/**
 *  \file       CapProcessor.java
 *  \ingroup    build
 *  \brief      File of class with CAP 1.2 builder
 *  \standards  from http://docs.oasis-open.org/emergency/cap/v1.2/CAP-v1.2-os.html
 *
 */
    
    public class CapProcessor{
        private boolean debug = false;
        String mime; // CAP / XML
        String output_destination; // output/
        String output_content;
        String error;

        CapCreate capCreate;
        //CapRead capRead;
        String capSoap;

        alertBlock[] alert = new alertBlock[0];
        private int alertIndex = 0;

        CapProcessor( String output, String cap_mime){
            if(output == null) output = "output";
            if(cap_mime == null) cap_mime = "xml";
            mime = cap_mime;
            output_destination = output;

            capCreate = new CapCreate(this);
            //capRead = new CapRead(this);
        }

        // returns the alert hendler for the given index
        public alertBlock getAlert(int index){
            return alert[index];
        }

        // sets/adds an alert block
        public alertBlock[] setAlert(){
            return alert = this.push(alert, new alertBlock());
        }

        // adds an alert block [relink: setAlert()]
        public alertBlock[] addAlert(){
            return this.setAlert();
        }

        // converts cap object to a xml string
        public String buildCap(int index){
            return this.capCreate.buildCap(index);
        }
        
        // saves a xml string cap to a file
        public String saveCap(String name, int index) throws FileNotFoundException, UnsupportedEncodingException{
            return this.capCreate.saveCap(name, index);
            //return "Not Aviable";
        }

        // reads a xml file, array or string and put it into the class
        public void readCap(String destination){
            //this.capRead.readCap(destination);
        }

        // returns the readed cap xml array of the index
        public String getCapXmlArray(int index){
            //return this.capRead.cap_xml_contend[index];
            return "Not Aviable";
        }

        // fills the Class with test values
        public void makeTestCAP(boolean debug){
            this.debug = debug;

            this.addAlert();
            alertBlock alertB = this.getAlert(0);

            alertB.setIdentifier("test.123456789.123");
            alertB.setSender("test.at");
            alertB.setSent(System.currentTimeMillis());
            alertB.setStatus("Test");
            alertB.setMsgType("Ack");
            alertB.setSource("cap.class.php makeTestCAP()");
            alertB.setScope("Private");
            //$alert->setRestriction("none");
            alertB.setAddresses("Teststreet 12");

            alertB.setCode("TESTFLAG1", 0);
            alertB.setCode("TESTFLAG3", 1);
            alertB.setCode("TESTFLAG2", 1); // Change second code entery from 3 to 2

            alertB.setNote("This was generated by the makeTestCAP function of the CAP Class");
            alertB.setReferences("test.at,test.123456789.122,"+System.currentTimeMillis());
            alertB.setIncidents("test.123456789.121 test.123456789.120");

                alertB.addInfo();
                infoBlock info = alertB.getInfo(0);
                
                info.setLanguage("english");

                info.setCategory("Other", 0);
                info.setCategory("Met", 1);
                info.setCategory("Rescue", 0); // Change Other to Rescue

                info.setEvent("TEST GENERATED MESSAGE");

                info.setResponseType("Assess", 0);
                info.setResponseType("None", 1);

                info.setUrgency("Immediate");
                info.setSeverity("Minor");
                info.setCertainty("Observed");
                info.setAudience("To all affected people");

                info.setEventCode("SAME", "CEM", 0);
                info.setEventCode("SYSTEM", "ACK", 1);

                info.setEffective(System.currentTimeMillis());
                info.setOnset(System.currentTimeMillis());
                info.setExpires(System.currentTimeMillis());

                info.setSenderName("CAP PHP Library");
                info.setHeadline("GENERATED TEST MESSAGE FROM CAP CLASS!");
                info.setDescription("THIS IS A GENERATED TEST MESSAGE FROM THE CAP CLASS!");
                info.setInstruction("CHECK IF SYSTEM IS RESPONDING");
                info.setWeb("http://localhost;");
                info.setContact("testmail@address.com");
                info.setParameter("SYSTEMID", "123", 0);
                info.setParameter("STATUS", "OFF", 1);
                info.setParameter("STATUS", "ON", 1); // Change STATUS to ON
                info.setParameter("TESTING", "TRUE", 2);

                    info.addResource();
                    resourceBlock resource = info.getResource(0);

                    resource.setResourceDesc("GOOGLE TEST PIC");
                    resource.setMimeType("image/png");
                    resource.setSize("105121");
                    resource.setUri("https://www.google.at/images/nav_logo242.png");
                    //resource.derefUri("105121");
                    resource.setDigest("a94a8fe5ccb19ba61c4c0873d391e987982fbbd3");

                    info.addArea();
                    areaBlock area = info.getArea(0);

                    area.setAreaDesc("TEST LOCATION");
                    area.setPolygon("43.00121,32.00121 43.00131,32.00141 43.00151,32.00161 43.00171,32.00181 43.00121,32.00121", 0);
                    area.setPolygon("42.00181,33.00131 42.00151,33.00141 42.00121,33.00171 42.00131,33.00141 42.00181,33.00131", 1);
                    area.setCircle("43.00121,32.00121 15", 0);
                    area.setCircle("42.00181,33.00131 15", 1);
                    area.setGeocode("FIPS", "FL0124", 0);
                    area.setGeocode("FIPS", "FL0125", 1);
                    area.setAltitude("1000");
                    area.setCeiling("1500");

                    info.addArea();
                    areaBlock area2 = info.getArea(1);
                    
                    area2.setAreaDesc("TEST LOCATION 2");
                    area2.setPolygon("53.00121,42.00121 53.00131,42.00141 53.00151,42.00161 53.00171,42.00181 53.00121,42.00121", 0);
                    area2.setPolygon("52.00181,43.00131 52.00151,43.00141 52.00121,43.00171 52.00131,43.00141 52.00181,43.00131", 1);
                    area2.setCircle("53.00121,42.00121 15", 0);
                    area2.setCircle("52.00181,43.00131 15", 1);
                    area2.setGeocode("FIPS", "FL0134", 0);
                    area2.setGeocode("FIPS", "FL0135", 1);
                    area2.setAltitude("1500");
                    area2.setCeiling("2000");

            this.debug(this.toString());
        }
        
        /*
         * Function to Debug cap.class.php
         *
         * @return array    $this   All content of the Class
         */ 
        public void debug(String debug_val){
            if(this.debug == true)
            {
                System.out.println(debug_val);        
            }
        }

        private alertBlock[] push(alertBlock[] array, alertBlock push) {
            alertBlock[] longer = new alertBlock[array.length + 1];
            System.arraycopy(array, 0, longer, 0, array.length);
            longer[array.length] = push;
            return longer;
        }
    }


    /**
     *  Get and Set <alert> CAP values
     *  The container for all component parts of the alert message (REQUIRED)
     */
    class alertBlock{
        protected String[] required = {"identifier", "sender", "sent", "status", "msgType", "scope"};
        protected String[] subclass = {"infoBlock"};

        // WMO Organisation ID green -> Your Country ISO Code -> Your File Date/Time "YYMMDDHHMMSS" -> your warning ID (CHAR max Len: 20 / special characters are not allowed only a-Z 0-9 and "_") -> 2.49.0.3.0.AT.150112080000.52550478
        String identifier;
        // link to Homepage Guaranteed by assigner to be unique globally
        String sender;
        // <yyyy>-<MM>-<dd>T<HH>:<mm>:<ss>+<hour>:<min><P> Offset to UTC (e.g. CET: +01:00; CEST: +02:00) -> 2014-07-15T06:03:02+01:00
        String sent;
        // Actual / Test / Exercise / System / Test / Draft
        String status;
        // Alert / Update / Cancel / Ack / Error
        String msgType;
        String source;
        // Public / Restricted / Private
        String scope;
        String restriction;
        String addresses;
        String[] code = new String[0];
        int codeIndex = 0;
        String note;
        // web / identifier / sent [from the older Cap (only fore Update and Cancel)] -> http://www.zamg.ac.at/warnsys/public/aus_all.html,2.49.0.3.0.AT.150115080000.52550477,2015-01-08T10:05:02+01:00
        String references;
        String incidents;
        infoBlock[] info = new infoBlock[0];
        int infoIndex = 0;

        // The identifier of the alert message (REQUIRED)
        public String getIdentifier(){ return identifier; }
        public String setIdentifier(String val){ return identifier = val;}
        
        // The identifier of the sender of the alert message (REQUIRED)
        public String getSender(){ return sender; }
        public String setSender(String val){ return sender = val; }
        
        // The time and date of the origination of the alert message (REQUIRED)
        public String getSent(){ return sent; }
        public String setSent(long val){ 
            SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssXXX");
            return sent = formatter.format(val);
        }
        
        // The code denoting the appropriate handling of the alert message (REQUIRED)
        public String getStatus(){ return status; }
        public String setStatus(String val){ 
            switch(val){
                case "Actual":
                case "Exercise":
                case "System":
                case "Test":
                case "Draft":
                    return status = val;
                default:
                    return "false";
            }
        }
        
        // The code denoting the nature of the alert message (REQUIRED)
        public String getMsgType(){ return msgType; }
        public String setMsgType( String val){ 
            switch(val){
                case "Alert":
                case "Update":
                case "Cancel":
                case "Ack":
                case "Error":
                    return msgType = val;
                default:
                    return "false";
            }
        }
        
        // The text identifying the source of the alert message (OPTIONAL)
        public String getSource(){ return source; }
        public String setSource(String val){ return source = val; }

        // The code denoting the intended distribution of the alert message (REQUIRED)
        public String getScope(){ return scope; }
        public String setScope(String val){ 
            switch(val){
                case "Public":
                case "Restricted":
                case "Private":
                    return scope = val;
                default:
                    return "false";
            }
        }

        // The text describing the rule for limiting distribution of the restricted alert message (CONDITIONAL)
        public String getRestriction(){ return restriction; }
        public String setRestriction(String val){ return restriction = val; }
        
        // The group listing of intended recipients of the alert message (CONDITIONAL)
        public String getAddresses(){ return addresses; }
        public String setAddresses(String val){ return addresses = val; }
        
        // The code denoting the special handling of the alert message (OPTIONAL)
        // TODO
        public String[] getCode(){ return code; }
        public String[] setCode(String val, int index){ 
            return code = this.push(code, val); // CHANGE
        }
        
        // The text describing the purpose or significance of the alert message (OPTIONAL)
        public String getNote(){ return note; }
        public String setNote(String val){ return note = val; }
                
        // The group listing identifying earlier message(s) referenced by the alert message (OPTIONAL)
        public String getReferences(){ return references; }
        public String setReferences(String val){ return references = val; }

        // The group listing naming the referent incident(s) of the alert message (OPTIONAL)
        public String getIncidents(){ return incidents; }
        public String setIncidents(String val){ return incidents = val; }

        public infoBlock getInfo(int index){
            return info[index];
        }

        public infoBlock[] setInfo(){
            return info = this.push(info, new infoBlock());
        }

        public infoBlock[] addInfo(){
            return this.setInfo();
        }
        
        private infoBlock[] push(infoBlock[] array, infoBlock push) {
            infoBlock[] longer = new infoBlock[array.length + 1];
            System.arraycopy(array, 0, longer, 0, array.length);
            longer[array.length] = push;
            return longer;
        }
        
        private String[] push(String[] array, String push) {
            String[] longer = new String[array.length + 1];
            System.arraycopy(array, 0, longer, 0, array.length);
            longer[array.length] = push;
            return longer;
        }
    }
    /**
     *  Get and Set <info> CAP values
     *  The container for all component parts of the info sub-element of the alert message (OPTIONAL)
     */
    class infoBlock{
        protected String[] required = {"category", "event", "urgency", "severity", "certainty"};
        protected String[] subclass = {"parameterBlock", "resourceBlock", "areaBlock"};

        // language-COUNTRY Format RFC 3066 Specification: de-DE -> German
        String language = "en-US";
        // Geo / Met / Safety / Security / Rescue / Fire / Health / Env / Transport / Infra / CBRNE / Other
        String[] category = new String[0];
        private int categoryIndex = 0;
        // The text denoting the type of the subject event of the alert message
        String event;
        // Shelter / Evacuate / Prepare / Execute / Avoid / Monitor / Assess / AllClear / None
        String[] responseType = new String[0];
        private int responseTypeIndex=0;
        // Immediate / Expected / Future / Past
        String urgency;
        // Extreme / Severe / Moderate / Minor / Unknown
        String severity;
        // Observed / Likely / Possible/ Unlikely / Unknown
        String certainty;
        // The text describing the intended audience of the alert message 
        String audience;
        // <eventCode>  <valueName>valueName</valueName>  <value>value</value></eventCode>
        parameterBlock[] eventCode = new parameterBlock[0];
        private int eventCodeIndex=0;
        // The effective time(oid)                                                      / Form: <yyyy>-<MM>-T<HH>:<mm>:<ss>+<hour>:<min> Offset to UTC 
        String effective;
        // The expected time of the beginning of the subject event of the alert message / Form: <yyyy>-<MM>-T<HH>:<mm>:<ss>+<hour>:<min> Offset to UTC -> 2015-01-08T10:05:02+01:00
        String onset;
        // The expiry time of the information of the alert message                      / Form: <yyyy>-<MM>-T<HH>:<mm>:<ss>+<hour>:<min> Offset to UTC -> 2015-01-08T15:00:13+01:00
        String expires;
        // The text naming the originator of the alert message  (The human-readable name of the agency or authority issuing this alert.) -> ZAMG Österreich
        String senderName;
        // The text headline of the alert message 
        String headline;
        // The text describing the subject event of the alert message 
        String description;
        // The text describing the recommended action to be taken by recipients of the alert message 
        String instruction;
        // The identifier of the hyperlink associating additional information with the alert message 
        String web;
        // The text describing the contact for follow-up and confirmation of the alert message 
        String contact;
        // A system-specific additional parameter associated with the alert message (as example meteoalarm.eu using it as specific warnings identifier) <parameter>  <valueName>valueName</valueName>  <value>value</value></parameter>
        parameterBlock[] parameter = new parameterBlock[0];
        private int parameterIndex=0;
        resourceBlock[] resource = new resourceBlock[0];
        private int resourceIndex=0;
        areaBlock[] area = new areaBlock[0];
        private int areaIndex=0;

        // The code denoting the language of the info sub-element of the alert message (OPTIONAL)
        public String getLanguage(){ return language; }
        public String setLanguage(String val){ return language = val; }
        
        // The code denoting the category of the subject event of the alert message (REQUIRED)
        public String[] getCategory(){ return category; }
        public String[] setCategory(String val, int index){ 
            switch(val){
                case "Geo":
                case "Met":
                case "Safety":
                case "Security":
                case "Rescue":
                case "Fire":
                case "Health":
                case "Env":
                case "Transport":
                case "Infra":
                case "CBRNE":
                case "Other":
                    return category = this.push(category, val);
                default:
                    return null;
            }
        }
        
        // The text denoting the type of the subject event of the alert message (REQUIRED)
        public String getEvent(){ return event; }
        public String setEvent(String val){ return event = val; }
        
        // The code denoting the type of action recommended for the target audience (OPTIONAL)
        public String[] getResponseType(){ return responseType; }
        public String[] setResponseType(String val, int index){ 
            switch(val){
                case "Shelter":
                case "Evacuate":
                case "Prepare":
                case "Execute":
                case "Avoid":
                case "Monitor":
                case "Assess":
                case "AllClear":
                case "None":
                    return responseType = this.push(responseType, val);
                default:
                    return null;
            }
        }
        
        // The code denoting the urgency of the subject event of the alert message (REQUIRED)
        public String getUrgency(){ return urgency; }
        public String setUrgency(String val){ 
            switch(val){
                case "Immediate":
                case "Expected":
                case "Future":
                case "Past":
                case "Unknown":
                    return urgency = val;
                default:
                    return "false";
            }
        }
        
        // The code denoting the severity of the subject event of the alert message (REQUIRED)
        public String getSeverity(){ return severity; }
        public String setSeverity(String val){ 
            switch(val){
                case "Extreme":
                case "Severe":
                case "Moderate":
                case "Minor":
                case "Unknown":
                    return severity = val;
                default:
                    return "false";
            }
        }
        
        // The code denoting the certainty of the subject event of the alert message (REQUIRED)
        public String getCertainty(){ return certainty; }
        public String setCertainty(String val){ 
            switch(val){
                case "Observed":
                case "Likely":
                case "Possible":
                case "Unlikely":
                case "Unknown":
                    return certainty = val;
                default:
                    return "false";
            }
        }
        
        // The text describing the intended audience of the alert message (OPTIONAL)
        public String getAudience(){ return audience; }
        public String setAudience(String val){ return audience = val; }
        
        // A system-specific code identifying the event type of the alert message (OPTIONAL)
        public parameterBlock[] getEventCode(){ return eventCode; }
        public parameterBlock[] setEventCode(String valn, String val, int index){ 
            return eventCode = this.push(eventCode, new parameterBlock(valn, val));
        }
        
        // The effective time of the information of the alert message (OPTIONAL)
        public String getEffective(){ return effective; }
        public String setEffective(long val){ 
            SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssXXX");
            return effective = formatter.format(val);
        }
        
        // The expected time of the beginning of the subject event of the alert message (OPTIONAL)
        public String getOnset(){ return onset; }
        public String setOnset(long val){
            SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssXXX");
            return onset = formatter.format(val);
        }
        
        // The expiry time of the information of the alert message (OPTIONAL)
        public String getExpires(){ return expires; }
        public String setExpires(long val){ 
            SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssXXX");
            return expires = formatter.format(val);
        }
        
        // The text naming the originator of the alert message (OPTIONAL)
        public String getSenderName(){ return senderName; }
        public String setSenderName(String val){ return senderName = val; }
        
        // The text headline of the alert message (OPTIONAL)
        public String getHeadline(){ return headline; }
        public String setHeadline(String val){ return headline = val; }
        
        // The text describing the subject event of the alert message (OPTIONAL)
        public String getDescription(){ return description; }
        public String setDescription(String val){ return description = val; }
        
        // The text describing the recommended action to be taken by recipients of the alert message (OPTIONAL)
        public String getInstruction(){ return instruction; }
        public String setInstruction(String val){ return instruction = val; }
        
        // The identifier of the hyperlink associating additional information with the alert message (OPTIONAL)
        public String getWeb(){ return web; }
        public String setWeb(String val){ return web = val; }
        
        // The text describing the contact for follow-up and confirmation of the alert message (OPTIONAL)
        public String getContact(){ return contact; }
        public String setContact(String val){ return contact = val; }
        
        // A system-specific additional parameter associated with the alert message (OPTIONAL)
        public parameterBlock[] getParameter(){ return parameter; }
        public parameterBlock[] setParameter(String valn, String val, int index){ 
            return parameter = this.push(parameter, new parameterBlock(valn, val));
        }

        public resourceBlock getResource(int index){
            return resource[index];
        }

        public resourceBlock[] setResource(){
            return resource = this.push(resource, new resourceBlock());
        }
        public resourceBlock[] addResource(){
            return this.setResource();
        }

        public areaBlock getArea(int index){
            return area[index];
        }

        public areaBlock[] setArea(){
            return area = this.push(area, new areaBlock());
        }
        public areaBlock[] addArea(){
            return this.setArea();
        }
        
        private parameterBlock[] push(parameterBlock[] array, parameterBlock push) {
            parameterBlock[] longer = new parameterBlock[array.length + 1];
            System.arraycopy(array, 0, longer, 0, array.length);
            longer[array.length] = push;
            return longer;
        }
        
        private resourceBlock[] push(resourceBlock[] array, resourceBlock push) {
            resourceBlock[] longer = new resourceBlock[array.length + 1];
            System.arraycopy(array, 0, longer, 0, array.length);
            longer[array.length] = push;
            return longer;
        }
        
        private areaBlock[] push(areaBlock[] array, areaBlock push) {
            areaBlock[] longer = new areaBlock[array.length + 1];
            System.arraycopy(array, 0, longer, 0, array.length);
            longer[array.length] = push;
            return longer;
        }
        
        private String[] push(String[] array, String push) {
            String[] longer = new String[array.length + 1];
            System.arraycopy(array, 0, longer, 0, array.length);
            longer[array.length] = push;
            return longer;
        }
    }
    /**
     *  Get and Set <resource> CAP values
     *  The container for all component parts of the resource sub-element of the info sub-element of the alert element (OPTIONAL)
     */
    class resourceBlock{
        protected String[] required = {"resourceDesc", "mimeType"};
        String resourceDesc;
        String mimeType;
        String size;
        String uri;
        String derefUri;
        String digest;
        
        // The text describing the type and content of the resource file (REQUIRED)
        public String getResourceDesc(){ return resourceDesc; }
        public String setResourceDesc(String val){ return resourceDesc = val; }
        
        // The identifier of the MIME content type and sub-type describing the resource file (REQUIRED)
        public String getMimeType(){ return mimeType; }
        public String setMimeType(String val){ return mimeType = val; }
        
        // The integer indicating the size of the resource file (OPTIONAL)
        public String getSize(){ return size; }
        public String setSize(String val){ return size = val; }
        
        // The identifier of the hyperlink for the resource file (OPTIONAL)
        public String getUri(){ return uri; }
        public String setUri(String val){ return uri = val; }
        
        // The base-64 encoded data content of the resource file (CONDITIONAL)
        public String getDerefUri(){ return derefUri; }
        public String setDerefUri(String val){ return derefUri = val; }
        
        // The code representing the digital digest (“hash”) computed from the resource file (OPTIONAL)
        public String getDigest(){ return digest; }
        public String setDigest(String val){ return digest = val; }
        
    }
    /**
     *  Get and Set <area> CAP values 
     *  The container for all component parts of the area sub-element of the info sub-element of the alert message (OPTIONAL)
     */
    class areaBlock{
        protected String[] required = {"areaDesc"};
        protected String[] subclass = {"parameterBlock"};
        // A text description of the affected area. -> Niederösterreich
        String areaDesc;
        // The paired values of points defining a polygon that delineates the affected area of the alert message 
        String[] polygon = new String[0];
        private int polygonIndex = 0;   
        // The paired values of a point and radius delineating the affected area of the alert message
        String[] circle = new String[0];
        private int circleIndex = 0;
        // <geocode><valueName>valueName</valueName>  <value>value</value></geocode> -> valueName: NUTS2 value: AT12
        parameterBlock[] geocode = new parameterBlock[0];
        private int geocodeIndex = 0;
        String altitude;
        String ceiling;
        
        // The container for all component parts of the area sub-element of the info sub-element of the alert message (OPTIONAL)
        public String getAreaDesc(){ return areaDesc; }
        public String setAreaDesc(String val){ return areaDesc = val; }
                
        // The text describing the affected area of the alert message (REQUIRED)
        public String[] getPolygon(){ return polygon; }
        public String[] setPolygon(String val, int index){ 
            return polygon = this.push(polygon, val);
        }
        
        // The paired values of a point and radius delineating the affected area of the alert message (OPTIONAL)
        public String[] getCircle(){ return circle; }
        public String[] setCircle(String val, int index){ 
            return circle = this.push(circle, val);
        }
        
        // The geographic code delineating the affected area of the alert message (OPTIONAL)
        public parameterBlock[] getGeocode(){ return geocode; }
        public parameterBlock[] setGeocode( String valn, String val, int index){
            return geocode = this.push(geocode, new parameterBlock(valn, val));
        }

        // The specific or minimum altitude of the affected area of the alert message (OPTIONAL)
        public String getAltitude(){ return altitude; }
        public String setAltitude(String val){ return altitude = val; }

        // The maximum altitude of the affected area of the alert message (CONDITIONAL)
        public String getCeiling(){ return ceiling; }
        public String setCeiling(String val){ return ceiling = val; }
        
        private parameterBlock[] push(parameterBlock[] array, parameterBlock push) {
            parameterBlock[] longer = new parameterBlock[array.length + 1];
            System.arraycopy(array, 0, longer, 0, array.length);
            longer[array.length] = push;
            return longer;
        }
        
        private String[] push(String[] array, String push) {
            String[] longer = new String[array.length + 1];
            System.arraycopy(array, 0, longer, 0, array.length);
            longer[array.length] = push;
            return longer;
        }
    }

    class parameterBlock {
        protected String[] required = {"valueName","value"};
        String valueName;
        String value;
        
        parameterBlock(String vn, String v){
            this.setValueName(vn);
            this.setValue(v);       
        }
        
        public void setValueName(String str){
            valueName = str;
        }
        
        public void setValue(String str){
            value = str;
        }
    }

    /*********************************
     *      CAP XML Create Class      *
     *********************************/

    class CapCreate{
        CapProcessor processor;

        CapCreate(CapProcessor processorClass){
            processor = processorClass;
        }

        /**
         * build CAP 1.2 content XML
         *
         * @return  None
         */
        public String buildCap(int index)
        {
            alertBlock alert = processor.getAlert(index);
            
            String[] oempty= null;
            String[] option = {"standalone","yes"};
            String[] option2 = {"xmlns", "urn:oasis:names:tc:emergency:cap:1.2"};
                    
            XmlProcessor xml = new XmlProcessor(/*ver*/"1.0",/*encoding*/"utf-8", option);
            xml.tag_open("alert", option2);
            
                xml.tag_simple("identifier", alert.identifier, oempty, 0);
                xml.tag_simple("sender", alert.sender, oempty, 0);
                xml.tag_simple("sent", alert.sent, oempty, 0);
                xml.tag_simple("status", alert.status, oempty, 0);
                xml.tag_simple("msgType", alert.msgType, oempty, 0);
                xml.tag_simple("source", alert.source, oempty, 0);
                xml.tag_simple("scope", alert.scope, oempty, 0);
                xml.tag_simple("restriction", alert.restriction, oempty, 0);
                xml.tag_simple("addresses", alert.addresses, oempty, 0);

                if(alert.code != null)
                for(String val : alert.code){
                    xml.tag_simple("code", val, oempty, 0);
                }

                xml.tag_simple("note", alert.note, oempty, 0);
                xml.tag_simple("references", alert.references, oempty, 0);
                xml.tag_simple("incidents", alert.incidents, oempty, 0);
                
                if(alert.info != null)
                for(int i = 0; i <= alert.info.length - 1; i++)
                {
                    infoBlock info = alert.info[i];
                    xml.tag_open("info", oempty);
                        
                        xml.tag_simple("language", info.language, oempty, 0);
                        if(info.category != null)
                        for(int ci = 0; ci <= info.category.length - 1; ci++) {
                            xml.tag_simple("category", info.category[ci], oempty, 0);
                        }

                        xml.tag_simple("event", info.event, oempty, 0);

                        if(info.responseType != null)
                        for(int ri = 0; ri <= info.responseType.length - 1; ri++) {
                            xml.tag_simple("responseType", info.responseType[ri], oempty, 0);
                        }

                        xml.tag_simple("urgency", info.urgency, oempty, 0);
                        xml.tag_simple("severity", info.severity, oempty, 0);
                        xml.tag_simple("certainty", info.certainty, oempty, 0);
                        xml.tag_simple("audience", info.audience, oempty, 0);
                        
                        if(info.eventCode != null)
                        for(int evi = 0; evi <= info.eventCode.length - 1; evi++) {
                            parameterBlock evv = info.eventCode[evi];
                            if(evv.valueName != null) {
                                xml.tag_open("eventCode", oempty);                            
                                    xml.tag_simple("valueName", evv.valueName, oempty, 0);
                                    xml.tag_simple("value", evv.value, oempty, 0);                         
                                xml.tag_close("eventCode");
                            }
                        }
                        
                        xml.tag_simple("effective", info.effective, oempty, 0);
                        xml.tag_simple("onset", info.onset, oempty, 0);
                        xml.tag_simple("expires", info.expires, oempty, 0);
                        
                        xml.tag_simple("senderName", info.senderName, oempty, 0);

                        xml.tag_simple("headline", info.headline, oempty, 0);
                        xml.tag_simple("description", info.description, oempty, 0);
                        xml.tag_simple("instruction", info.instruction, oempty, 0);
                        
                        xml.tag_simple("web", info.web, oempty, 0);
                        xml.tag_simple("contact", info.contact, oempty, 0);
                        
                        if(info.parameter != null)
                        for(int pai = 0; pai <= info.parameter.length - 1; pai++) {
                            parameterBlock pav = info.parameter[pai];
                            if(pav.valueName != null) {
                                xml.tag_open("parameter", oempty);                        
                                    xml.tag_simple("valueName", pav.valueName, oempty, 0);
                                    xml.tag_simple("value", pav.value, oempty, 0);                         
                                xml.tag_close("parameter");           
                            }           
                        } // foreach parameter
                        
                        if(info.resource != null)
                        for(int rei = 0; rei <= info.resource.length - 1; rei++) {
                            resourceBlock rev = info.resource[rei];
                            xml.tag_open("resource", oempty);

                                xml.tag_simple("resourceDesc", rev.resourceDesc, oempty, 0);
                                xml.tag_simple("mimeType", rev.mimeType, oempty, 0);
                                xml.tag_simple("size", rev.size, oempty, 0);
                                xml.tag_simple("uri", rev.uri, oempty, 0);
                                xml.tag_simple("derefUri", rev.derefUri, oempty, 0);
                                xml.tag_simple("digest", rev.digest, oempty, 0);

                            xml.tag_close("resource");
                        }
                        
                        if(info.area != null)
                        for(int ari = 0; ari <= info.area.length - 1; ari++) {
                            areaBlock arv = info.area[ari];
                            
                            xml.tag_open("area", oempty);
                        
                                xml.tag_simple("areaDesc", arv.areaDesc, oempty, 0);

                                if(arv.polygon != null)
                                for(int poli = 0; poli <= arv.polygon.length - 1; poli++) {
                                    xml.tag_simple("polygon", arv.polygon[poli], oempty, 0);
                                }
                            
                                if(arv.circle != null)
                                for(int ciri = 0; ciri <= arv.circle.length - 1; ciri++) {
                                    xml.tag_simple("circle", arv.circle[ciri], oempty, 0);
                                }
                            
                                if(arv.geocode != null)
                                for(int geoi = 0; geoi <= arv.geocode.length - 1; geoi++) {
                                    parameterBlock gev = arv.geocode[geoi];
                                    if(gev.valueName != null) {
                                        xml.tag_open("geocode", oempty);
                                            xml.tag_simple("valueName", gev.valueName, oempty, 0);
                                            xml.tag_simple("value", gev.value, oempty, 0);                         
                                        xml.tag_close("geocode");
                                    }
                                } // foreach geocode

                                xml.tag_simple("altitude", arv.altitude, oempty, 0);
                                xml.tag_simple("ceiling", arv.ceiling, oempty, 0);
                            
                            xml.tag_close("area");
                        }
                                            
                    xml.tag_close("info");
                }
                    
            xml.tag_close("alert");
            
            return this.processor.output_content = xml.output(); 
        }

        public String saveCap(String name, int index) throws FileNotFoundException, UnsupportedEncodingException{
            
            
            PrintWriter writer = new PrintWriter(name, "UTF-8");
            writer.println(this.processor.output_content);
            writer.close();
            
            return "TEST";
        }

        /**
         * Create File
         *
         * @return  path of the New CAP 1.2
          // TODO
        public String saveCap(String name, int index)
        {
            $alert = $this->processor->getAlert($index);
            if($alert->identifier != "")
            {
                if($name == '') $name = $alert->identifier;
                if(substr($name,-5,5) == '.xml') $end_type = ""; else $end_type = ".xml";
                $capfile = fopen($this->processor->output_destination.'/'.$name.$end_type, "w");
                if($capfile === false) return "Unable to open file! ".$this->processor->output_destination.'/'.$name.$end_type;
                fwrite($capfile, $this->processor->output_content);
                fclose($capfile);

                chmod($this->processor->output_destination.'/'.$name.$end_type, 0660);  // octal; correct value of mode
                chgrp($this->processor->output_destination.'/'.$name.$end_type, filegroup($this->processor->output_destination)); 
                
                // convert in UTF-8
                $data = file_get_contents($this->processor->output_destination.'/'.$name.$end_type);
                
                if (!preg_match('!!u', $data)){ //this is not utf-8
                   $data = mb_convert_encoding($data, 'UTF-8', 'OLD-ENCODING');
                }
                
                file_put_contents($this->processor->output_destination.'/'.$name.$end_type, $data);
                
                return $this->processor->output_destination.'/'.$name.$end_type;
            }
            else
            {
                return false;
            }
        }
        * */
    }

    /*********************************
     *      CAP XML Read Class      *
     ********************************
    // TODO
    class CapRead{
        
        var $processor;
        var $process_class = array();
        var $cap_xml_contend = array();
        var $cap_xml_contend_index = 0;
        var $is_start = true;
        var $read_count = 0;

        function __construct(CapProcessor $processorClass){
            $this->processor = $processorClass;
        }

        function readCap($xml){
            $this->is_start = true;
            $this->process_class = array();
            if(@is_file($xml)) { // @silent because its posible that this is no path!
                // load XML file into object
                $xml_processed = simplexml_load_file($xml);                    
            } elseif(is_array($xml) || is_object($xml)) {
                // load xml object
                $xml_processed = $xml;
            } elseif(is_string($xml)) {
                // load xml string
                $xml_processed = simplexml_load_string($xml);
            }  else {
                // xml can not be parsed
                $xml_processed = false;           
            }
            if($xml_processed){
                // parse xml object
                $this->cap_xml_contend[$this->cap_xml_contend_index++] = $xml_processed;
                $this->readCapArray($xml_processed);
            }
        }

        function readCapArray($xml_object,$spec_class='', $class='')
        {       
            if($spec_class && method_exists($class, 'add'.ucfirst($spec_class))){
                $process_class_{$spec_class} = $class->{'add'.ucfirst($spec_class)}();
            }
            if($this->is_start)
            {
                $spec_class = 'alert';
                $process_class_{$spec_class} = $this->processor->addAlert();
                $this->is_start = false;
            }
            foreach($xml_object as $key => $val){

                if(!empty($val->valueName) && method_exists($process_class_{$spec_class}, 'set'.ucfirst($key))) {
                    $process_class_{$spec_class}->{'set'.ucfirst($key)}($val->valueName, $val->value);

                } else if(class_exists($key.'Block')){
                    $this->readCapArray($val,$key, $process_class_{$spec_class});

                } else if(method_exists($process_class_{$spec_class}, 'set'.ucfirst($key))) {
                    $process_class_{$spec_class}->{'set'.ucfirst($key)}($val);
                }
            }
        }
    }
    */
    /*********************************
     *      CAP XML write Class      *
     *********************************/

    class XmlProcessor{
       
       String[] file = new String[0];
       String breakLine = "\r\n";
       String tabspace = "\t ";
       String lt = "<";
       String gt = ">";
       
       int tab = 0;
       String[] tab_tree = new String[0];
       
        /**
         * initialize XML
         *
         * @param   string  $version            The version of the XML
         * @param   string  $encoding           The encoding of the XML
         * @param   string  $options            The options of the XML
         * @return  None
         **/        
        XmlProcessor(String version, String encoding, String[] options){
            
            this.addrow(("<"+"?xml version=\""+version+"\" encoding=\""+encoding+"\""+this.aToT(options)+" ?"+">"));
        }
           
        /**
         * make a tag in the XML file
         *
         * @param   string  $tag                    The name of the XML Tag
         * @param   string  $value              The value of the XML Tag
         * @param   array       $options            The options of the XML Tag
         * @param   int         $trimtext           Trim or not Trim XML Tag value
         * @return  None
         **/
        public void tag_simple(String tag,String value,String[] options, int trimtext)
        {           
            if(trimtext == 1) value = value.trim(); 
            if(value == null && options == null ) return;
        
                String row = (this.lt+tag+this.aToT(options));
                if(value.trim() != "") {
                    row+= (this.gt);
                    row+= this.stringToHtmlString(value); 
                    row+= (this.lt+"/"+tag+this.gt);
                } else {
                    if(tag == "summary"){
                        row+= (this.gt);
                        row+= "No Summary";
                        row+= (this.lt+"/"+tag+this.gt);
                    }else{
                        row+= ("/"+this.gt);
                    }
                }
            this.addrow(row);
        }
           
        /**
         * make a open tag in the XML file
         *
         * @param   string  $tag                    The name of the XML Tag
         * @param   array       $options            The options of the XML Tag
         * @return  None
         **/
        public void tag_open(String tag,String[] options){
            String row =( this.lt+tag+this.aToT(options)+this.gt );
            this.addrow(row);
            this.tab++;   
            this.tab_tree = this.push(this.tab_tree,tag);
        }
           
        /**
         * close a open tag in the XML file
         *
         * @param   string  $tag                    The name of the XML Tag
         * @return  None
         **/
        public void tag_close(String tagv){
            //int c=0;
            //String ltag;
            //if(this.tab > 0)
                //do{
                    //ltag = this.tab_tree[this.tab_tree.length];
                    this.tab--;
                    String row = (this.lt+"/"+tagv+this.gt);
                    this.addrow(row);
                    //c++;
                //}while((ltag != tagv || (this.isNumeric(tagv) != false && c < Integer.parseInt(tagv))) && this.tab > 0  );  // ( this.isNumeric(tag) != false & c < Integer.parseInt(tag) )          
                
        }
           
        /**
         * Make a blank line in the XML file
         *
         * @return  None
        **/
        public void add_emptyrow(){
            this.addrow("");
        }
           
        /**
         * Make a <![CDATA[]]> Tag in the XML File
         *
         * @param   string  $value                  The name of the CDATA Tag
         * @return  None
         **/
        public String cdata(String value){
            return "<![CDATA["+value+"]]>";
        }
           
        /**
         *
         **/
        public String tab(){
            String row = "";
            for(int i = 0; i < this.tab; i++){
                row+= this.tabspace;
            }
            return row;
        }
           
        /**
         * Add a row with content in the XML File
         *
         * @param   string  $content                    The Content wich should be added
         * @return  None
        **/
        public void addrow(String content){
            this.file = this.push(this.file, this.tab() + content + this.breakLine);
        }
           
        /**
         * make the option style
         *
         * @param   array   $options                    The options wich should be added
         * @return  None
         **/
        public String aToT(String[] options){
            if(options == null) return "";
            String ret = "";
            return ret;
        }
           
        /**
         * Add a Comment
         *
         * @param   string  $comment                    the comment
         * @return  None
         **/
        public void addComment(String comment){
            this.addrow(("<!--"+comment+"-->"));
        }
           
        private static int[] push(int[] array, int push) {
            int[] longer = new int[array.length + 1];
            System.arraycopy(array, 0, longer, 0, array.length);
            longer[array.length] = push;
            return longer;
        }
        
        private String[] push(String[] array, String push) {
            String[] longer = new String[array.length + 1];
            System.arraycopy(array, 0, longer, 0, array.length);
            longer[array.length] = push;
            return longer;
        }
        
        public boolean isNumeric(String str){  
          try{  
            double d = Double.parseDouble(str);  
          } catch(NumberFormatException nfe) {  
            return false;  
          }  
          return true;  
        }
        
        public String stringToHtmlString(String s){
            StringBuilder sb = new StringBuilder();
            int n = s.length();
            for (int i = 0; i < n; i++) {
              char c = s.charAt(i);
              switch (c) {
                 case '<': sb.append("&lt;"); break;
                 case '>': sb.append("&gt;"); break;
                 case '&': sb.append("&amp;"); break;
                 case '"': sb.append("&quot;"); break;
                 default:  sb.append(c); break;
              }
            }
            return sb.toString();
        }
        
        /**
         * Output The File
         *
         * @return  $this->file     All content of the File
         **/
        public String output(){
            return String.join("", this.file);
        } 
    }